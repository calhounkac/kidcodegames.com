<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bow & Arrow: Skeletons vs Pumpkins</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1220; color: #e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    header { display: flex; gap: 16px; align-items: center; padding: 12px 16px; background: #0f172a; border-bottom: 1px solid #1f2937; }
    header h1 { font-size: 16px; margin: 0; letter-spacing: 0.3px; font-weight: 600; }
    header .btn { background: #111827; color: #e5e7eb; border: 1px solid #374151; padding: 8px 12px; border-radius: 12px; cursor: pointer; }
    header .btn:hover { background: #1f2937; }
    header .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background: #111827; border: 1px solid #374151; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
    #game { display: grid; grid-template-columns: 1fr 320px; gap: 16px; padding: 16px; }
    #canvas { width: 100%; height: 100%; background: linear-gradient(#0b1220, #0e1629); border: 1px solid #1f2937; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35) inset; }
    aside { background: #0f172a; border: 1px solid #1f2937; border-radius: 16px; padding: 14px; display: grid; gap: 10px; align-content: start; }
    .stat { display: flex; justify-content: space-between; font-size: 14px; }
    .bar { height: 10px; background: #111827; border: 1px solid #374151; border-radius: 999px; overflow: hidden; }
    .bar > div { height: 100%; background: linear-gradient(90deg, #22c55e, #16a34a); width: 0%; }
    footer { padding: 8px 16px; color: #9ca3af; border-top: 1px solid #1f2937; font-size: 12px; }
    .hint { color: #9ca3af; font-size: 12px; }
    .targets-legend { display: flex; gap: 10px; align-items: center; font-size: 18px; }
    .pill { display: inline-flex; align-items: center; gap: 8px; background: #0b1220; border: 1px solid #1f2937; padding: 6px 10px; border-radius: 999px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üèπ Bow & Arrow: Skeletons vs Pumpkins</h1>
      <button id="resetBtn" class="btn">Reset (R)</button>
      <div class="pill hint">Hold <span class="kbd">mouse / touch</span> to draw. Release to shoot. Aim with cursor.</div>
      <div class="pill hint">Toggle slow-mo: <span class="kbd">S</span></div>
      <div class="pill hint">Mute: <span class="kbd">M</span></div>
    </header>

    <main id="game">
      <canvas id="canvas" width="960" height="540" aria-label="Bow and arrow game canvas" role="img"></canvas>
      <aside>
        <div class="targets-legend">
          <div class="pill">üéØ Hit: <strong>+10</strong></div>
          <div class="pill">üéÉ Pumpkin: <strong>x1</strong></div>
          <div class="pill">üíÄ Skeleton: <strong>x2</strong></div>
        </div>
        <div class="stat"><span>Score</span><span id="score">0</span></div>
        <div class="stat"><span>Shots</span><span id="shots">0</span></div>
        <div class="stat"><span>Hits</span><span id="hits">0</span></div>
        <div class="stat"><span>Accuracy</span><span id="acc">0%</span></div>
        <div class="bar" title="Charge level"><div id="chargeBar"></div></div>
        <div class="hint">Tip: Aim slightly above your target to account for gravity.</div>
        <div class="hint">Mobile: tap-hold to draw, release to fire.</div>
      </aside>
    </main>

    <footer>
      Built with plain HTML5 canvas & JavaScript. No external assets. Spooky fun üéÉ
    </footer>
  </div>

  <script>
    // --- Utility
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => a + Math.random() * (b - a);

    // --- Audio (very lightweight beeps)
    let audioEnabled = true;
    function beep(freq = 660, dur = 0.05, vol = 0.05) {
      if (!audioEnabled || !window.AudioContext) return;
      const ctx = beep.ctx || (beep.ctx = new AudioContext());
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'triangle';
      o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g).connect(ctx.destination);
      o.start();
      o.stop(ctx.currentTime + dur);
    }

    // --- Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Scale for HiDPI
    function scaleForHiDPI() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const { width, height } = canvas;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    scaleForHiDPI();
    window.addEventListener('resize', scaleForHiDPI);

    // --- Game state
    const state = {
      score: 0,
      shots: 0,
      hits: 0,
      arrows: [],
      targets: [],
      bow: { x: 80, y: canvas.height / (window.devicePixelRatio||1) - 120, angle: -0.2, power: 0, drawing: false },
      gravity: 700, // px/s^2
      slowmo: false,
      lastTime: 0,
      spawnTimer: 0,
      spawnEvery: 1.0,
    };

    // --- UI refs
    const elScore = document.getElementById('score');
    const elShots = document.getElementById('shots');
    const elHits = document.getElementById('hits');
    const elAcc = document.getElementById('acc');
    const elCharge = document.getElementById('chargeBar');

    function updateHUD() {
      elScore.textContent = state.score;
      elShots.textContent = state.shots;
      elHits.textContent = state.hits;
      const acc = state.shots ? Math.round((state.hits / state.shots) * 100) : 0;
      elAcc.textContent = acc + '%';
    }

    // --- Input handling (mouse & touch)
    const pointer = { x: 0, y: 0, down: false };

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (evt.clientX - rect.left) * (canvas.width / rect.width) / (window.devicePixelRatio||1),
        y: (evt.clientY - rect.top) * (canvas.height / rect.height) / (window.devicePixelRatio||1)
      };
    }

    canvas.addEventListener('mousemove', (e) => {
      const pos = getMousePos(e);
      pointer.x = pos.x; pointer.y = pos.y;
      const dx = pointer.x - state.bow.x;
      const dy = pointer.y - state.bow.y;
      state.bow.angle = Math.atan2(dy, dx);
    });

    canvas.addEventListener('mousedown', () => { pointer.down = true; state.bow.drawing = true; beep(220, .04, .03); });
    canvas.addEventListener('mouseup', () => releaseShot());
    canvas.addEventListener('mouseleave', () => { if (pointer.down) releaseShot(); pointer.down = false; });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      pointer.x = (t.clientX - rect.left) * (canvas.width / rect.width) / (window.devicePixelRatio||1);
      pointer.y = (t.clientY - rect.top) * (canvas.height / rect.height) / (window.devicePixelRatio||1);
      const dx = pointer.x - state.bow.x; const dy = pointer.y - state.bow.y; state.bow.angle = Math.atan2(dy, dx);
      pointer.down = true; state.bow.drawing = true; beep(220, .04, .03);
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      pointer.x = (t.clientX - rect.left) * (canvas.width / rect.width) / (window.devicePixelRatio||1);
      pointer.y = (t.clientY - rect.top) * (canvas.height / rect.height) / (window.devicePixelRatio||1);
      const dx = pointer.x - state.bow.x; const dy = pointer.y - state.bow.y; state.bow.angle = Math.atan2(dy, dx);
    }, { passive: false });

    canvas.addEventListener('touchend', () => { releaseShot(); pointer.down = false; }, { passive: false });

    // --- Keyboard
    document.getElementById('resetBtn').addEventListener('click', resetGame);
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') resetGame();
      if (e.key.toLowerCase() === 's') state.slowmo = !state.slowmo;
      if (e.key.toLowerCase() === 'm') audioEnabled = !audioEnabled;
    });

    // --- Shooting
    function releaseShot() {
      if (!state.bow.drawing) return;
      pointer.down = false;
      state.bow.drawing = false;
      const power = state.bow.power; // 0..1
      if (power <= 0.05) { state.bow.power = 0; return; }
      const speed = 450 + power * 550; // px/s
      const vx = Math.cos(state.bow.angle) * speed;
      const vy = Math.sin(state.bow.angle) * speed;
      state.arrows.push({ x: state.bow.x + 30 * Math.cos(state.bow.angle), y: state.bow.y + 30 * Math.sin(state.bow.angle), vx, vy, rot: state.bow.angle, alive: true });
      state.shots++; updateHUD();
      state.bow.power = 0;
      beep(520, .06, .05);
    }

    // --- Targets
    function spawnTarget() {
      const isSkeleton = Math.random() < 0.4; // 40% skeletons, rest pumpkins
      const size = isSkeleton ? 38 : 44; // emoji font size baseline
      const yBandTop = 100; const yBandBottom = canvas.height / (window.devicePixelRatio||1) - 220;
      const y = rand(yBandTop, yBandBottom);
      const fromLeft = Math.random() < 0.5;
      const x = fromLeft ? -60 : (canvas.width / (window.devicePixelRatio||1)) + 60;
      const speed = (isSkeleton ? 85 : 60) * (fromLeft ? 1 : -1);
      state.targets.push({ x, y, vx: speed, size, type: isSkeleton ? 'skeleton' : 'pumpkin', alive: true, value: isSkeleton ? 20 : 10 });
    }

    // --- Physics & Update
    function update(dt) {
      // Bow charge when drawing
      if (state.bow.drawing) {
        state.bow.power = clamp(state.bow.power + dt * 0.7, 0, 1);
      } else {
        state.bow.power = clamp(state.bow.power - dt * 2.4, 0, 1);
      }
      elCharge.style.width = (state.bow.power * 100).toFixed(0) + '%';

      // Spawn targets
      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0) {
        spawnTarget();
        state.spawnTimer = rand(state.spawnEvery * 0.5, state.spawnEvery * 1.25);
      }

      // Update arrows
      for (const a of state.arrows) {
        if (!a.alive) continue;
        a.vy += state.gravity * dt;
        a.x += a.vx * dt;
        a.y += a.vy * dt;
        a.rot = Math.atan2(a.vy, a.vx);
        // Out of bounds
        if (a.x > canvas.width || a.x < -50 || a.y > canvas.height || a.y < -50) a.alive = false;
      }

      // Update targets
      for (const t of state.targets) {
        if (!t.alive) continue;
        t.x += t.vx * dt;
        if (t.x < -100 || t.x > (canvas.width / (window.devicePixelRatio||1)) + 100) t.alive = false;
      }

      // Collisions (simple circle hit on emoji bounds)
      for (const a of state.arrows) {
        if (!a.alive) continue;
        for (const t of state.targets) {
          if (!t.alive) continue;
          const r = (t.size * 0.6);
          const dx = (a.x) - (t.x);
          const dy = (a.y) - (t.y - t.size * 0.35); // nudge for emoji baseline
          if (dx*dx + dy*dy <= r*r) {
            t.alive = false; a.alive = false;
            state.hits++; state.score += 10 * (t.type === 'skeleton' ? 2 : 1);
            updateHUD();
            // pop effect
            for (let i=0; i<10; i++) particles.push(makeParticle(t.x, t.y, t.type));
            beep(t.type==='skeleton'? 300:420, .05, .06);
          }
        }
      }

      // Cleanup
      state.arrows = state.arrows.filter(a => a.alive);
      state.targets = state.targets.filter(t => t.alive);

      // Slight difficulty ramp
      state.spawnEvery = clamp(state.spawnEvery - dt * 0.01, 0.6, 1.2);
    }

    // --- Particles
    const particles = [];
    function makeParticle(x, y, type) {
      return { x, y, vx: rand(-150,150), vy: rand(-200, -50), life: 0.5, age: 0, type };
    }
    function updateParticles(dt) {
      for (const p of particles) {
        p.age += dt; p.vy += state.gravity * 0.6 * dt; p.x += p.vx * dt; p.y += p.vy * dt;
      }
      for (let i = particles.length - 1; i >= 0; i--) if (particles[i].age > particles[i].life) particles.splice(i,1);
    }

    // --- Drawing
    function draw() {
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);

      // Sky gradient + ground
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, '#0b1220'); grad.addColorStop(1, '#0e1629');
      ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);

      // Ground line
      ctx.strokeStyle = '#243040'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, h-80); ctx.lineTo(w, h-80); ctx.stroke();

      // Moon
      ctx.beginPath(); ctx.fillStyle = '#e5e7eb'; ctx.arc(w-80, 80, 28, 0, Math.PI*2); ctx.fill();

      // Bow & player
      drawBow();

      // Targets
      for (const t of state.targets) {
        const emoji = t.type === 'skeleton' ? 'üíÄ' : 'üéÉ';
        ctx.font = `${t.size}px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.fillText(emoji, 0, 0);
        ctx.restore();
      }

      // Arrows
      for (const a of state.arrows) {
        ctx.save();
        ctx.translate(a.x, a.y);
        ctx.rotate(a.rot);
        // shaft
        ctx.fillStyle = '#d1d5db';
        ctx.fillRect(-14, -2, 28, 4);
        // tip
        ctx.beginPath(); ctx.moveTo(14, 0); ctx.lineTo(22, -3); ctx.lineTo(22, 3); ctx.closePath();
        ctx.fillStyle = '#9ca3af'; ctx.fill();
        // fletching
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(-18, -4, 4, 8);
        ctx.restore();
      }

      // Particles
      for (const p of particles) {
        const t = clamp(1 - p.age / p.life, 0, 1);
        ctx.globalAlpha = t;
        ctx.fillStyle = p.type==='skeleton'? '#9ca3af' : '#f97316';
        ctx.beginPath(); ctx.arc(p.x, p.y, 3 + 2*(1-t), 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      }

      // HUD crosshair on pointer
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,.2)'; ctx.lineWidth = 1;
      ctx.arc(pointer.x, pointer.y, 10, 0, Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(pointer.x-14, pointer.y); ctx.lineTo(pointer.x+14, pointer.y); ctx.moveTo(pointer.x, pointer.y-14); ctx.lineTo(pointer.x, pointer.y+14); ctx.stroke();

      // Instructions watermark
      ctx.fillStyle = 'rgba(255,255,255,.12)'; ctx.font = '12px system-ui, sans-serif'; ctx.fillText('Hold to draw ‚Ä¢ Release to shoot ‚Ä¢ Aim above target', 14, h-56);
    }

    function drawBow() {
      const b = state.bow;
      const x = b.x, y = b.y;
      // Bow body
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(b.angle);
      ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 6; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.arc(-10, 0, 40, -Math.PI/2, Math.PI/2, false); ctx.stroke();
      // String
      ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-10, -40); ctx.lineTo(-10 + (b.power*10), 0); ctx.lineTo(-10, 40); ctx.stroke();
      // Hand
      ctx.fillStyle = '#ef4444'; ctx.fillRect(-6, -6, 12, 12);
      ctx.restore();

      // Archer stand
      ctx.fillStyle = '#374151';
      ctx.fillRect(x-18, y+40, 36, 60);
      ctx.fillRect(x-10, y+100, 20, 10);
    }

    // --- Loop
    function loop(ts) {
      if (!state.lastTime) state.lastTime = ts;
      let dt = (ts - state.lastTime) / 1000;
      state.lastTime = ts;
      dt = clamp(dt, 0, 0.033);
      if (state.slowmo) dt *= 0.35;

      update(dt);
      updateParticles(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function resetGame() {
      state.score = 0; state.shots = 0; state.hits = 0; updateHUD();
      state.arrows = []; state.targets = []; state.spawnEvery = 1.0; state.spawnTimer = 0.2;
      state.bow.power = 0; state.bow.angle = -0.2;
      particles.length = 0;
      beep(180, .06, .05);
    }

    // Boot
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
